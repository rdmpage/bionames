{
   "_id": "_design/taxonName",
   "_rev": "7-826ef23f61dd96de3abcc4bbacaff8b2",
   "language": "javascript",
   "views": {
       "nameString": {
           "map": "/*\nIndex all likely ways of writing this name, \nincluding with and without subgenus. Goal is to\nmake it easy to find name. */\n\nfunction(doc) {\n  if (doc.type == 'nameCluster')\n  {\n  \t\n    // 1. emit name as is\n    emit(doc.nameComplete, doc._id);\n    \n    // 2. handle multiple ways we can write the \"same\" name\n    if (doc.uninomial) \n    {\n      // ignore \n    } \n    else \n    {\n      if (doc.rankString)\n      {\n        switch(doc.rankString)\n        {\n          // For subgenus we index the infragenericEpithet \n          // so we can find it if promoted to genus\n          case 'subgenus':\n            if (doc.infragenericEpithet)\n            {\n               emit(doc.infragenericEpithet, doc._id);\n            } \n            break;\n\n          // index species with and without subgenus\n          case 'species':\n            if (doc.infragenericEpithet)\n            {  \n               // genus + species\n               var str = doc.genusPart + ' ' + doc.specificEpithet;\n\n               if (str != doc.nameComplete)\n               {\n                 emit(str, doc._id);\n               }\n               // subgenus + species\n               str = doc.infragenericEpithet + ' ' + doc.specificEpithet;\n\n               if (str != doc.nameComplete)\n               {\n                 emit(str, doc._id);\n               }\n            }\n            break;\n\n          // index subspecies with and without species and without subgenus\n          case 'subspecies':\n            if (doc.infragenericEpithet)\n            {  \n               // genus + species + subspecies\n               emit(doc.genusPart + ' ' + doc.specificEpithet + ' ' + doc.infraspecificEpithet, doc._id);\n            }\n            // genus + subspecies\n            emit(doc.genusPart + ' ' + doc.infraspecificEpithet, doc._id);\n            break;\n \n          default:\n            break;\n         }\n      }\n    }\n  \n    /*\n    for (i in doc.names)\n    {\n  \n    // 1. emit name as is\n    emit(doc.names[i].nameComplete, doc._id);\n\n    // 2. handle multiple ways we can write the \"same\" name\n    if (doc.names[i].uninomial) \n    {\n      // ignore \n    } \n    else \n    {\n      if (doc.names[i].rankString)\n      {\n        switch(doc.names[i].rankString)\n        {\n          // For subgenus we index the infragenericEpithet \n          // so we can find it if promoted to genus\n          case 'subgenus':\n            if (doc.names[i].infragenericEpithet)\n            {\n               emit(doc.names[i].infragenericEpithet, doc._id);\n            } \n            break;\n\n          // index species with and without subgenus\n          case 'species':\n            if (doc.names[i].infragenericEpithet)\n            {  \n               // genus + species\n               var str = doc.names[i].genusPart + ' ' + doc.names[i].specificEpithet;\n\n               if (str != doc.names[i].nameComplete)\n               {\n                 emit(str, doc._id);\n               }\n               // subgenus + species\n               str = doc.names[i].infragenericEpithet + ' ' + doc.names[i].specificEpithet;\n\n               if (str != doc.names[i].nameComplete)\n               {\n                 emit(str, doc._id);\n               }\n            }\n            break;\n\n          // index subspecies with and without species and without subgenus\n          case 'subspecies':\n            if (doc.names[i].infragenericEpithet)\n            {  \n               // genus + species + subspecies\n               emit(doc.names[i].genusPart + ' ' + doc.names[i].specificEpithet + ' ' + doc.infraspecificEpithet, doc._id);\n            }\n            // genus + subspecies\n            emit(doc.names[i].genusPart + ' ' + doc.names[i].infraspecificEpithet, doc._id);\n            break;\n \n          default:\n            break;\n         }\n      }\n    }\n  }\n  */\n}\n}"
       },
       "name_id_to_cluster": {
           "map": "/*\nOutput ids of names in cluster\n*/\n\nfunction(doc) {\n  if (doc.type == 'nameCluster')\n  {\n    for (i in doc.names)\n    {\n      emit(doc.names[i].id, doc._id);\n    }\n  }\n}\n"
       },
       "epithet_author": {
           "map": "/*\nIndex epithets with authorship\n*/\n\nfunction(doc) {\n  if (doc.type == 'nameCluster')\n  {  \t\n    if (doc.uninomial) \n    {\n      // ignore \n    } \n    else \n    {\n    \tvar epithet = '';\n    \t\n    \tif (doc.infraspecificEpithet) {\n    \t\tepithet = doc.infraspecificEpithet;\n    \t} else if (doc.specificEpithet) {\n    \t\tepithet = doc.specificEpithet;\n    \t}\n    \t\n    \tif ((epithet != '') && doc.taxonAuthor) { \n          var author =  doc.taxonAuthor;\n          author = author.replace(/\\(/, '');\n          author = author.replace(/\\)/, '');  \t\n    \t  emit(epithet + ' ' + author, doc.nameComplete);\n\n          // if author has date index authorshp without date\n          var pattern = /(.*)\\s+([1|2][0-9]{3})$/;\n          var match = pattern.exec(author);\t\t\t\t\t\t\t\t\t\n          if (match) {\n            emit(epithet + ' ' + match[1], doc.nameComplete);\n          }\n    \t}\n    }\n  }\n}"
       },
       "year": {
           "map": "/* Count of published names per year */\nfunction(doc) {\n  if (doc.type == 'nameCluster') {\n    if (doc.publication) {\n      if (doc.publication.length > 0) {\n        if (doc.year) {\n          emit(doc.year[0], 1);\n        }\n      }\n    }\n  }\n}",
           "reduce": "function (key, values, rereduce) {\n    return sum(values);\n}"
       },
       "nameComplete": {
           "map": "/*\n emit nameComplete as is for quick lookup of id\n*/\nfunction(doc) {\n  if (doc.type == 'nameCluster') {\n     emit(doc.nameComplete, doc._id);\n  }\n}"
       },
       "nameComplete_to_id": {
           "map": "/*\nOutput name linked to id\n*/\n\nfunction(doc) {\n  if (doc.type == 'nameCluster') {\n    for (i in doc.names) {\n      emit(doc.nameComplete, doc.names[i].id);\n    }\n  }\n}\n"
       },
       "microreference": {
           "map": "/*\nOutput microreference for taxon name\n*/\n\nfunction(doc) {\n  if (doc.type == 'nameCluster') {\n    for (i in doc.names) {\n      if (doc.names[i].publishedInCitation && doc.names[i].microreference) {\n        emit(doc._id, [doc.names[i].id, doc.names[i].publishedInCitation,doc.names[i].microreference]);\n      }\n    }\n  }\n}"
       }
   }
}